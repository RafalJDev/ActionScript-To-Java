package pl.logicsynergy.ui.common.customer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import logica.appl.validators.NipValidator;
import logica.appl.validators.PeselValidator;
import logica.appl.validators.RegonValidator;
import logica.data.DataMap;
import logica.utils.StringUtils;
import pl.logicsynergy.annotations.UiDesign;
import pl.logicsynergy.components.DatabaseField;
import pl.logicsynergy.components.TextInput;
import pl.logicsynergy.components.grid.GridModes;
import pl.logicsynergy.components.mdi.UiMdiTab;
import pl.logicsynergy.components.ui.ResultFunction;
import pl.logicsynergy.components.ui.UiMessageBox;
import pl.logicsynergy.creator.UiCreator;
import pl.logicsynergy.database.DBManager;
import pl.logicsynergy.database.DBQuery;
import pl.logicsynergy.database.ValidationFunction;
import pl.logicsynergy.events.BaseEvent;
import pl.logicsynergy.ro.ROUiEventService;

@UiDesign(formName = "Dane", guid = "54BCCED1")
public class TabCustomerData extends UiMdiTab
{
	/** DatabaseFieldy odpowiedzialne za grupy użytkowników */
	public DatabaseField dbfGroup1;
	public DatabaseField dbfGroup2;
	public DatabaseField dbfGroup3;
	public DatabaseField dbfCustomerConsultant;

	/** TextInputy przechowujące PESEL, NIP oraz REGON */
	public TextInput txtPESEL;
	public TextInput txtNIP;
	public TextInput txtREGON;

	/** DataMapa do obsługi kontrahenta */
	private DataMap customerWithSomethingElseExists = new DataMap();

	/**
	 * pole przechowujące instancję bieżącego ekranu, używane w DBFunction zamiast
	 * 'this'
	 */
	private TabCustomerData here = this;

	/**
	 * Konstruktor
	 */
	public TabCustomerData()
	{
		UiCreator.getInstance(self).executeXML();
		load();
	}

	/**
	 * Nadpisana metoda load z klasy bazowej
	 */
	@Override
	public void load()
	{
		super.load();
		setEvents();
	}

	/**
	 * Nadpisana metoda z klasy bazowej ustawiająca mdiDBManagera
	 */
	@Override
	protected void mdiMainSetDbManager(BaseEvent event)
	{
		super.mdiMainSetDbManager(event);

		if (getDBManager() != null)
		{
			getDBManager().setSaveValidationFunction(validateData);
		}
	}

	/**
	 * Metoda odpowiedzialna za ustawienie eventów na kontrolkach
	 */
	private void setEvents()
	{
		txtPESEL.addEventListener(BaseEvent.VALUE_CHANGED, event -> checkNipPeselRegon(event));
		txtNIP.addEventListener(BaseEvent.VALUE_CHANGED, event -> checkNipPeselRegon(event));
		txtREGON.addEventListener(BaseEvent.VALUE_CHANGED, event -> checkNipPeselRegon(event));
	}

	/**
	 * Metoda odpowiedzialna za walidację nr PESEL, NIPu oraz REGONu.
	 */
	private void checkNipPeselRegon(BaseEvent event)
	{
		if (getDBManager().getMode() == GridModes.VIEW)
		{
			return;
		}
		checkIfCustomerExists(event.getSource().getId());
	}

	/**
	 * Metoda odpowiedzialna za sprawdzeniem czy dany kontrahent istnieje.
	 * 
	 * @param componentID
	 *          ID sprawdzanego kontrahenta
	 */
	@SuppressWarnings("rawtypes")
	protected void checkIfCustomerExists(String componentID)
	{
		customerWithSomethingElseExists.put(componentID, false);

		String sqlWhere = "Active=1";
		List<Object> sqlParams = new ArrayList<>();

		if (componentID.equals("txtPESEL") && !StringUtils.isNullOrEmpty(txtPESEL.getValue().toString()))
		{
			sqlWhere += " And Pesel=? ";
			sqlParams.add(txtPESEL.getValue().toString().trim());
		}

		if (componentID.equals("txtNIP") && !StringUtils.isNullOrEmpty(txtNIP.getValue().toString()))
		{
			sqlWhere += " And NIP=? ";
			sqlParams.add(txtNIP.getValue().toString().trim());
		}

		if (componentID.equals("txtREGON") && !StringUtils.isNullOrEmpty(txtREGON.getValue().toString()))
		{
			sqlWhere += " And Regon=? ";
			sqlParams.add(txtREGON.getValue().toString().trim());
		}

		if (sqlParams.size() < 1)
		{
			return;
		}

		if (getDBManager().getMode() == 2)
		{
			Object customerCode = getDBManager().getValue("CODE", getDBManager().getCurrentIndex());
			if (customerCode != null)
			{
				sqlWhere += " And Code <> ?";
				sqlParams.add(customerCode.toString());
			}
		}

		DataMap data = new DataMap();
		data.put("Select", "count(1) as CNT, '" + componentID + "' as CHECKEDFIELD");
		data.put("From", "Common_Customer");
		data.put("Where", sqlWhere);
		data.put("PARAMS", sqlParams.toArray());

		DataMap resultMap = ROUiEventService.call("logica.uiservice.db.DatabaseManager", "getData", data);

		if (!ROUiEventService.isResultOk(resultMap))
		{
			return;
		}

		ArrayList<Object> temp1 = (ArrayList) resultMap.get("DataTable");
		HashMap temp2 = (HashMap) temp1.get(0);
		int ctn = (int) temp2.get("CNT");
		String field = (String) temp2.get("CHECKEDFIELD");

		if (ctn > 0)
		{
			customerWithSomethingElseExists.put(field, true);
		}
	}

	/**
	 * Funkcja walidująca numery identyfikacyjne kontrahenta
	 */
	ValidationFunction validateData = new ValidationFunction()
	{
		@Override
		public boolean validation(DataMap map)
		{
			List<Object> fields = new ArrayList<>();
			PeselValidator peselValidator = new PeselValidator();
			if (!peselValidator.check(txtPESEL.getValue()))
			{
				fields.add(" PESEL");
			}

			NipValidator nipValidator = new NipValidator();
			if (!nipValidator.check(txtNIP.getValue()))
			{
				fields.add(" NIP");
			}

			RegonValidator regonValidator = new RegonValidator();
			if (!regonValidator.check(txtREGON.getValue()))
			{
				fields.add(" REGON");
			}

			List<Object> customerExistsMsg = new ArrayList<>();

			for (String field : customerWithSomethingElseExists.keySet())
			{
				if ((boolean) customerWithSomethingElseExists.get(field) == true)
				{
					customerExistsMsg.add(field.replaceAll("txt", " ").toUpperCase());
				}
			}

			if (fields.size() > 0 || customerExistsMsg.size() > 0)
			{
				getDBManager().allowSave = false;

				String message = "";

				if (fields.size() > 0)
				{
					for (Object field : fields)
					{
						message += field + " ";
					}
					message = "Nieprawidłowe wielkości pól: " + message + ".\n";
				}

				if (customerExistsMsg.size() > 0)
				{
					message += "Istnieje już kontrahent z podanym numerem: " + customerExistsMsg.get(0) + ".\n";
				}

				message += "Czy chcesz zatwierdzić wprowadzanie rekordu?";

				UiMessageBox.showYESNO(here, message, "Błędna walidacja pól", onValidationMessage);
			}
			return true;
		}
	};

	/**
	 * ResultFunction odpowiedzialny za obsługę zamknięcia grida i odpowiednie
	 * ustawienie jego trybu
	 */
	ResultFunction onValidationMessage = new ResultFunction()
	{
		@Override
		public void onClose(DataMap data)
		{
			getDBManager().allowSave = true;

			if (!data.get("DialogResult").equals("YES"))
			{
				return;
			}

			getDBManager().save();
			getDBManager().setMode(GridModes.VIEW);
			customerWithSomethingElseExists = new DataMap();
		}
	};

	/**
	 * Nadpisana metoda setDbManager z klasy bazwoej
	 */
	@Override
	public void setDbManager(DBManager value)
	{
		super.setDbManager(value);
		setEvents();
	}

	/**
	 * Metoda DataExchange ustawiająca odpowienie parametry dla zapytania dla
	 * DataBaseFielda
	 * 
	 * @return DataMap z parametrami
	 */
	public DataMap getDbfGroup1DataExchange()
	{
		DataMap dataExchange = new DataMap();
		dataExchange.put("type", 1);
		dataExchange.put("dbQuery.sqlFrom", "Common_GroupCustomer1");
		dataExchange.put("formName", "Grupa podziału I");
		return dataExchange;
	}

	/**
	 * Metoda DataExchange ustawiająca odpowienie parametry dla zapytania dla
	 * DataBaseFielda
	 * 
	 * @return DataMap z parametrami
	 */
	public DataMap getDbfGroup2DataExchange()
	{
		DataMap dataExchange = new DataMap();
		dataExchange.put("type", 1);
		dataExchange.put("dbQuery.sqlFrom", "Common_GroupCustomer2");
		dataExchange.put("formName", "Grupa podziału II");
		return dataExchange;
	}

	/**
	 * Metoda DataExchange ustawiająca odpowienie parametry dla zapytania dla
	 * DataBaseFielda
	 * 
	 * @return DataMap z parametrami
	 */
	public DataMap getDbfGroup3DataExchange()
	{
		DataMap dataExchange = new DataMap();
		dataExchange.put("type", 1);
		dataExchange.put("dbQuery.sqlFrom", "Common_GroupCustomer3");
		dataExchange.put("formName", "Grupa podziału III");
		return dataExchange;
	}

	/**
	 * Metoda DataExchange ustawiająca odpowienie parametry dla zapytania dla
	 * DataBaseFielda
	 * 
	 * @return DataMap z parametrami
	 */
	public DataMap getDbfCCDataExchange()
	{
		DataMap dataExchange = new DataMap();
		dataExchange.put("type", 1);
		dataExchange.put("dbQuery.sqlFrom", "Common_CustomerConsultant");
		dataExchange.put("formName", "Opiekunowie kontrahentów");
		return dataExchange;
	}

	/**
	 * Podstawowe DBQuery pobierające dane z bazy
	 * 
	 * @return kontrolka zapytania
	 */
	public DBQuery dbConsultant()
	{
		DBQuery query = new DBQuery();
		query.sqlFrom = "Common_CustomerConsultant";
		query.sqlOrderBy = "Id";
		query.sqlIdentityColumn = "Id";
		query.sqlFieldString = "Id, Symbol , Name";
		return query;
	}

	/**
	 * DBQuery pobierające źródła danych
	 * 
	 * @return kontrolka zapytania
	 */
	public DBQuery dbDataSource()
	{
		DBQuery query = new DBQuery();
		query.sqlFrom = "Common_CustomerDataSource";
		query.sqlOrderBy = "Id";
		query.sqlIdentityColumn = "Id";
		query.sqlFieldString = "Id, Symbol , Name";
		return query;
	}

	/**
	 * DBQuery odpoweidzialne za pobieranie statusu
	 * 
	 * @return kontrolka zapytania
	 */
	public DBQuery dbStatus()
	{
		DBQuery query = new DBQuery();
		query.sqlFrom = "Common_CustomerStatus";
		query.sqlOrderBy = "Id";
		query.sqlIdentityColumn = "Id";
		query.sqlFieldString = "Id, Symbol , Name";
		return query;
	}

	/**
	 * DBQuery odpowiedzialne za pobieranie kontrahentów
	 * 
	 * @return kontrolka zapytania
	 */
	public DBQuery dbCustomer()
	{
		DBQuery query = new DBQuery();
		query.sqlFrom = "Common_Customer";
		query.sqlOrderBy = "Id";
		query.sqlIdentityColumn = "Id";
		query.sqlFieldString = "Id, Symbol, Name";
		return query;
	}

	/**
	 * DBQUery odpowiedzialne za obsługę grupy 1 kontrahentów
	 * 
	 * @return kontrolka zapytania
	 */
	public DBQuery dbGroupCustomer1()
	{
		DBQuery query = new DBQuery();
		query.sqlFrom = "Common_GroupCustomer1";
		query.sqlOrderBy = "Id";
		query.sqlIdentityColumn = "Id";
		query.sqlFieldString = "Id, Symbol, Name, Description";
		return query;
	}

	/**
	 * DBQUery odpowiedzialne za obsługę grupy 2 kontrahentów
	 * 
	 * @return kontrolka zapytania
	 */
	public DBQuery dbGroupCustomer2()
	{
		DBQuery query = new DBQuery();
		query.sqlFrom = "Common_GroupCustomer2";
		query.sqlOrderBy = "Id";
		query.sqlIdentityColumn = "Id";
		query.sqlFieldString = "Id, Symbol, Name, Description";
		return query;
	}

	/**
	 * DBQUery odpowiedzialne za obsługę grupy 1 kontrahentów
	 * 
	 * @return kontrolka zapytania
	 */
	public DBQuery dbGroupCustomer3()
	{
		DBQuery query = new DBQuery();
		query.sqlFrom = "Common_GroupCustomer3";
		query.sqlOrderBy = "Id";
		query.sqlIdentityColumn = "Id";
		query.sqlFieldString = "Id, Symbol, Name, Description";
		return query;
	}
}
